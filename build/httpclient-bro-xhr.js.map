{"version":3,"file":"httpclient-bro-xhr.js","mappings":";;;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,gCAAgC,kCAAkC,KAAK;AACnJ;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;;AAEA;AACA;AACA;;;;;AAKA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,oBAAoB,aAAa;AACjC,wBAAwB;AACxB;AACA;AACA;;AAEA,kBAAkB;AAClB;;AAEA;AACA,8BAA8B;;;AAG9B;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD,aAAa;;AAEb;AACA;;AAEA,MAAM;AACN;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA,sBAAsB,aAAa;AACnC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,0BAA0B;AAC1B,+DAA+D,mBAAmB,MAAM,KAAK;AAC7F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,0BAA0B;AAC1B,kFAAkF,cAAc;AAChG;AACA;AACA;AACA,OAAO;;;;AAIP,KAAK;;AAEL;AACA;;;;AAIA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA,6BAA6B,EAAE,sEAAsE;;AAErG,iEAAiE;AACjE,sBAAsB,iBAAiB,cAAc,eAAe,OAAO,UAAU,KAAK,QAAQ;;AAElG,iEAAiE;AACjE;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA,sBAAsB,cAAc,wBAAwB,kBAAkB,OAAO,IAAI;AACzF,+EAA+E;;AAE/E;AACA;;AAEA;AACA;;;AAGA;AACA;;;;AAIA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;AAIA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,KAAK;AACL;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA,wDAAwD;AACxD;AACA;;;;AAIA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,SAAS,oCAAoC,iCAAiC,SAAS;AAC7G;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;;AAGA;AACA;AACA,aAAa,UAAU,+DAA+D;AACtF,eAAe;AACf;AACA;AACA;AACA;;;;;;AAMA;;AAEA;AACA;AACA,aAAa,QAAQ,aAAa;AAClC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ,0BAA0B;AAC/C,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;;AAGA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;AAKA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C,oDAAoD;AACpD,oDAAoD;AACpD,4CAA4C;AAC5C,oDAAoD;AACpD,0DAA0D;AAC1D;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD,MAAM;AACN;AACA;AACA;;AAEA;;AAEA,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ,4BAA4B;AACjD,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA,sEAAe,gEAAgB,IAAC;;AAEhC;AACA;AACA,0BAA0B;AAC1B;AACA","sources":["webpack://@mikosoft/httpclient-bro/./HTTPClientBroXHR.js"],"sourcesContent":["class HTTPClientBroXHR {\n\n  /**\n   * Opts {\n   *  encodeURI:boolean,\n   *  timeout:number,\n   *  responseType: ''|'text'|'blob', // 'blob' for file download (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType)\n   *  retry:number,\n   *  retryDelay:number,\n   *  maxRedirects:number,\n   *  headers:object\n   * }\n   * @param {Object} opts - HTTP Client options {encodeURI, timeout, responseType, retry, retryDelay, maxRedirects, headers}\n   */\n  constructor(opts) {\n    this.url;\n    this.protocol = 'http:';\n    this.hostname = '';\n    this.port = 80;\n    this.pathname = '/';\n    this.queryString = '';\n\n    if (!opts) {\n      this.opts = {\n        encodeURI: false,\n        timeout: 8000,\n        responseType: '', // 'blob' for file download (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType)\n        retry: 3,\n        retryDelay: 5500,\n        maxRedirects: 3,\n        headers: {\n          authorization: '',\n          accept: '*/*' // 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'\n        }\n      };\n    } else {\n      this.opts = opts;\n    }\n\n    // initial values for timeout, responseType and req_headers\n    this.timeout = this.opts.timeout;\n    this.responseType = this.opts.responseType;\n    this.req_headers = { ...this.opts.headers };\n\n    // init the xhr\n    this.xhr = new XMLHttpRequest();\n\n    // set interceptor\n    this.interceptor;\n  }\n\n\n\n\n  /********** REQUESTS *********/\n\n  /**\n   * Sending one HTTP request to HTTP server.\n   *  - 301 redirections are not handled.\n   *  - retries are not handled\n   * @param {string} url - https://www.example.com/something?q=15\n   * @param {string} method - GET, POST, PUT, DELETE, PATCH\n   * @param {any} bodyPayload - http body payload\n   * @returns {Promise<answer>}\n   */\n  async askOnce(url, method = 'GET', bodyPayload) {\n\n    // answer (response object)\n    const answer = {\n      requestURL: url,\n      requestMethod: method,\n      status: 0,\n      statusMessage: '',\n      https: false,\n      req: {\n        headers: this.req_headers,\n        payload: undefined\n      },\n      res: {\n        headers: undefined,\n        content: undefined\n      },\n      time: {\n        req: this._getTime(),\n        res: undefined,\n        duration: undefined\n      }\n    };\n\n\n    // check and correct URL\n    try {\n      url = this._parseUrl(url);\n      answer.requestURL = url;\n      answer.https = /^https/.test(this.protocol);\n    } catch (err) {\n      // if URL is not properly defined\n      const ans = { ...answer }; // clone object to prevent overwrite of object properies once promise is resolved\n      ans.status = 400; // client error - Bad Request\n      ans.statusMessage = err.message || 'Bad Request';\n      ans.time.res = this._getTime();\n      ans.time.duration = this._getTimeDiff(ans.time.req, ans.time.res);\n\n      return ans; // send answer and stop further execution\n    }\n\n    /*** 0) intercept the request ***/\n    if (!!this.interceptor) { await this.interceptor(); }\n\n\n    /*** 1) init HTTP request ***/\n    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open\n    this.xhr.open(method, url, true, null, null);\n\n\n    // set the xhr options (works only after the xhr is opened)\n    this._xhr_timeout(this.timeout);\n    this._xhr_responseType(this.responseType);\n    this._xhr_requestHeaders(this.req_headers);\n\n\n    /*** 2) add body to HTTP request ***/\n    if (!!bodyPayload && !/GET/i.test(method)) {\n      answer.req.payload = bodyPayload;\n\n      const contentType = this.req_headers['content-type'] || '';\n      let body2send;\n      if (/application\\/json/.test(contentType)) { body2send = JSON.stringify(bodyPayload); }\n      else { body2send = bodyPayload; }\n\n      /*** 3) send request to server (with body) ***/\n      this.xhr.send(body2send);\n\n    } else {\n      /*** 3) send request to server (without body) ***/\n      this.xhr.send();\n    }\n\n\n\n    /** 4) wait for response */\n    const promise = new Promise((resolve, reject) => {\n\n      this.xhr.onload = res => {\n        // format answer\n        const ans = { ...answer }; // clone object to prevent overwrite of object properies once promise is resolved\n        ans.status = this.xhr.status; // 2xx -ok response, 4xx -client error (bad request), 5xx -server error\n        ans.statusMessage = this.xhr.statusText;\n        ans.res.headers = this.getResHeaders();\n        ans.res.content = res.target.response;\n        ans.time.res = this._getTime();\n        ans.time.duration = this._getTimeDiff(ans.time.req, ans.time.res);\n\n        resolve(ans);\n      };\n\n\n      this.xhr.onerror = error => {\n        this.kill();\n        const err = this._formatError(error, url);\n\n        // format answer\n        const ans = { ...answer }; // clone object to prevent overwrite of object properies once promise is resolved\n        ans.status = err.status;\n        ans.statusMessage = err.message;\n        ans.time.res = this._getTime();\n        ans.time.duration = this._getTimeDiff(ans.time.req, ans.time.res);\n\n        // do not resolve if it's already resolved by timeout\n        resolve(ans);\n      };\n\n\n\n      /*** TIMOUT ***/\n      this.xhr.ontimeout = () => {\n        this.kill();\n        // format answer\n        const ans = { ...answer }; // clone object to prevent overwrite of object properies once promise is resolved\n        ans.status = 408; // 408 - timeout\n        ans.statusMessage = `Request aborted due to timeout (${this.opts.timeout} ms) ${url} `;\n        ans.time.res = this._getTime();\n        ans.time.duration = this._getTimeDiff(ans.time.req, ans.time.res);\n        resolve(ans);\n      };\n\n      // force timeout when server doesn't send response\n      setTimeout(() => {\n        // format answer\n        const ans = { ...answer }; // clone object to prevent overwrite of object properies once promise is resolved\n        ans.status = 408; // 408 - timeout\n        ans.statusMessage = `Server did not respond and timeout is forced after ${this.timeout} ms.`;\n        ans.time.res = this._getTime();\n        ans.time.duration = this._getTimeDiff(ans.time.req, ans.time.res);\n        resolve(ans);\n      }, this.timeout);\n\n\n\n    });\n\n    return promise;\n  }\n\n\n\n  /**\n   * Sending HTTP request to HTTP server.\n   *  - 301 redirections are handled.\n   *  - retries are handled\n   * @param {String} url - https://www.example.com/contact\n   * @param {String} method - GET, POST, PUT, DELETE, PATCH\n   * @param {Object} bodyPayload - http body\n   * @returns {Promise<answer>}\n   */\n  async ask(url, method = 'GET', bodyPayload) {\n\n    let answer = await this.askOnce(url, method, bodyPayload);\n    const answers = [answer];\n\n\n    /*** a) HANDLE 3XX REDIRECTS */\n    let redirectCounter = 1;\n\n    while (!!answer && /^3\\d{2}/.test(answer.status) && redirectCounter <= this.opts.maxRedirects) { // 300, 301, 302, ...\n\n      const url_new = new URL(url, answer.res.headers.location); // redirected URL is in 'location' header\n      console.log(`#${redirectCounter} redirection ${answer.status} from ${this.url} to ${url_new}`);\n\n      answer = await this.askOnce(url_new, method, bodyPayload); // repeat request with new url\n      answers.push(answer);\n\n      redirectCounter++;\n    }\n\n\n    /*** b) HANDLE RETRIES when status = 408 timeout */\n    let retryCounter = 1;\n\n    while (answer.status === 408 && retryCounter <= this.opts.retry) {\n      console.log(`#${retryCounter} retry due to timeout (${this.opts.timeout}) on ${url}`);\n      await new Promise(resolve => setTimeout(resolve, this.opts.retryDelay)); // delay before retrial\n\n      answer = await this.askOnce(url, method, bodyPayload);\n      answers.push(answer);\n\n      retryCounter++;\n    }\n\n\n    return answers;\n  }\n\n\n\n  /**\n   * Fetch the JSON. Redirections and retries are not handled.\n   * @param {string} url - https://api.example.com/someurl\n   * @param {string} method - GET, POST, PUT, DELETE, PATCH\n   * @param {object|string} body - http body as Object or String JSON type\n   * @returns {Promise<answer>}\n   */\n  async askJSON(url, method = 'GET', body) {\n\n    // convert body string to object\n    let bodyPayload = body;\n    if (!!body && typeof body === 'string') {\n      try {\n        bodyPayload = JSON.parse(body);\n      } catch (err) {\n        throw new Error('Body string is not valid JSON.');\n      }\n    }\n\n    // JSON request headers\n    this.setReqHeaders({\n      'accept': 'application/json',\n      'content-type': 'application/json; charset=utf-8'\n    });\n\n    const answer = await this.askOnce(url, method, bodyPayload);\n\n    // convert content string to object\n    if (!!answer.res.content) {\n      try {\n        answer.res.content = JSON.parse(answer.res.content);\n      } catch (err) {\n        throw new Error('Response content is not valid JSON.');\n      }\n    }\n\n    return answer;\n  }\n\n\n\n  /**\n   * Get the HTML file content.\n   * @param {string} url - http://example.com/page.html\n   * @returns {Promise<answer>}\n   */\n  async askHTML(url) {\n    this.setReqHeaders({\n      'accept': 'text/html',\n      'content-type': 'text/html'\n    });\n    const answer = await this.askOnce(url, 'GET');\n    return answer;\n  }\n\n\n\n  /**\n   * Get the content of the Javascript file.\n   * @param {string} url - https://api.example.com/some.js\n   * @returns {Promise<answer>}\n   */\n  async askJS(url) {\n    this.setReqHeaders({\n      'accept': 'application/javascript',\n      'content-type': 'application/javascript; charset=utf-8'\n    });\n    const answer = await this.askOnce(url, 'GET');\n    return answer;\n  }\n\n\n\n  /**\n   * Send POST request where body is new FormData() object.\n   * For example (frontend code):\n   * // create form data\n   * const formData = new FormData();\n   * formData.append('db_id', db_id);\n   * formData.append('coll_name', coll_name);\n   * formData.append('csv_file', csv_file);\n   * @param {string} url - https://api.example.com/someurl\n   * @param {FormData} formData - the FormData instance\n   * @returns {Promise<answer>}\n   */\n  async sendFormData(url, formData) {\n    // content-type should be removed for multipart/form-data as defined at https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\n    this.setReqHeaders({\n      'accept': '*/*',\n      'content-type': `multipart/form-data`\n    });\n    this.delReqHeaders(['content-type']);\n\n    const answer = await this.askOnce(url, 'POST', formData);\n\n    // convert content string to object\n    if (!!answer.res.content) {\n      try {\n        answer.res.content = JSON.parse(answer.res.content);\n      } catch (err) {\n        console.log('WARNING: Response content is not JSON.');\n      }\n    }\n\n    return answer;\n  }\n\n\n  /**\n   * Convert JS Object to FormData and prepare it for sendFormData()\n   * @param {object} formObj - object which needs to be converted to FormData\n   * @returns {FormData}\n   */\n  object2formdata(formObj) {\n    const formData = new FormData();\n    for (const [key, val] of Object.entries(formObj)) { formData.set(key, val); }\n    return formData;\n  }\n\n\n\n  /** TODO\n   * Send HTML Form fields. Custom boundary for multipart/form-data .\n   * @param {string} url - https://api.example.com/someurl\n   * @param {FormData} formData - the FormData instance\n   * @param {string} contentType - request header content-type value, which can be application/x-www-form-urlencoded or multipart/form-data (for files) or text/plain (Forms with mailto:)\n   * @returns {Promise<answer>}\n   */\n  async sendForm(url, formData, contentType = 'application/x-www-form-urlencoded') {\n    // define boundary\n    let boundary = 'DodoWebHttpClient';\n    boundary += Math.floor(Math.random() * 32768);\n    boundary += Math.floor(Math.random() * 32768);\n    boundary += Math.floor(Math.random() * 32768);\n    console.log('boundary::', boundary);\n\n    const body = `--${boundary}\\r\\nContent-Disposition: form-data; name=\"db_id\"\\r\\n\\r\\n12345\\r\\n--${boundary}--`;\n    console.log('body::', body);\n\n    const answer = await this.askOnce(url, 'POST', formData);\n    return answer;\n  }\n\n\n\n  /**\n   * Stop the sent request immediatelly.\n   * @returns {void}\n   */\n  kill() {\n    this.xhr.abort();\n  }\n\n\n  /**\n   * Set the interceptor function which will be executed every time before the HTTP request is sent.\n   * @param {Function} interceptor - callback function, for example (httpClient) => { httpClient.setReqHeader('Authorization', 'JWT aswas); }\n   * @returns {void}\n   */\n  setInterceptor(interceptor) {\n    this.interceptor = interceptor.bind(this);\n  }\n\n\n\n\n\n  /********** HEADERS *********/\n\n  /**\n   * Change request header object. The headerObj will be appended to previously defined this.req_headers and headers with the same name will be overwritten.\n   * @param {Object} headerObj - {'authorization', 'user-agent', accept, 'cache-control', 'host', 'accept-encoding', 'connection'}\n   * @returns {void}\n   */\n  setReqHeaders(headerObj) {\n    Object.keys(headerObj).forEach(prop => {\n      const headerName = prop;\n      const headerValue = headerObj[prop];\n      this.setReqHeader(headerName, headerValue);\n    });\n  }\n\n  /**\n   * Set (add/update) request header.\n   * Previously defined header will be overwritten.\n   * @param {String} headerName - 'content-type'\n   * @param {String} headerValue - 'text/html; charset=UTF-8'\n   * @returns {void}\n   */\n  setReqHeader(headerName, headerValue) {\n    headerName = headerName.toLowerCase();\n    this.req_headers[headerName] = headerValue;\n  }\n\n  /**\n   * Delete multiple request headers.\n   * @param {Array} headerNames - array of header names, for example: ['content-type', 'accept']\n   * @returns {void}\n   */\n  delReqHeaders(headerNames) {\n    headerNames.forEach(headerName => {\n      delete this.req_headers[headerName];\n    });\n  }\n\n  /**\n   * Get request headers\n   * @returns {object}\n   */\n  getReqHeaders() {\n    return this.req_headers;\n  }\n\n\n  /**\n   * Get response HTTP headers.\n   * @returns {object}\n   */\n  getResHeaders() {\n    const headersStr = this.xhr.getAllResponseHeaders();\n    const headersArr = headersStr.split('\\n');\n    const headersObj = {};\n    headersArr.forEach(headerFull => {\n      const splited = headerFull.split(':');\n      const prop = splited[0];\n      if (prop) {\n        const val = splited[1].trim();\n        headersObj[prop] = val;\n      }\n    });\n    return headersObj;\n  }\n\n\n\n\n  /********** PRIVATES *********/\n\n  /**\n   * Parse url.\n   * @param {String} url - http://www.adsuu.com/some/thing.php?x=2&y=3\n   */\n  _parseUrl(url) {\n    url = this._correctUrl(url);\n    const urlObj = new URL(url);\n    this.url = url;\n    this.protocol = urlObj.protocol;\n    this.hostname = urlObj.hostname;\n    this.port = urlObj.port;\n    this.pathname = urlObj.pathname;\n    this.queryString = urlObj.search;\n\n    // debug\n    /*\n    console.log('this.url:: ', this.url); // http://localhost:8001/www/products?category=databases\n    console.log('this.protocol:: ', this.protocol); // http:\n    console.log('this.hostname:: ', this.hostname); // localhost\n    console.log('this.port:: ', this.port); // 8001\n    console.log('this.pathname:: ', this.pathname); // /www/products\n    console.log('this.queryString:: ', this.queryString); // ?category=databases\n    */\n\n    return url;\n  }\n\n\n  /**\n   * URL corrections\n   */\n  _correctUrl(url) {\n    if (!url) { throw new Error('URL is not defined'); }\n\n    // 1. trim from left and right\n    url = url.trim();\n\n    // 2. add protocol\n    if (!/^https?:\\/\\//.test(url)) {\n      url = 'http://' + url;\n    }\n\n    // 3. remove multiple empty spaces and insert %20\n    if (this.opts.encodeURI) {\n      url = encodeURI(url);\n    } else {\n      url = url.replace(/\\s+/g, ' ');\n      url = url.replace(/ /g, '%20');\n    }\n\n    return url;\n  }\n\n\n  /**\n   * Beautify error messages.\n   * @param {Error} error - original error\n   * @return formatted error\n   */\n  _formatError(error, url) {\n    // console.log('_formatError::', error, url);\n    const err = new Error(error);\n\n\n    // reformatting NodeJS errors\n    if (error.target.status === 0) {\n      err.status = 0;\n      err.message = `Status:0 Bad Request ${url}`;\n    } else {\n      err.status = error.status || 400;\n      err.message = error.message;\n    }\n\n    err.original = error;\n\n    return err; // formatted error is returned\n  }\n\n\n  /**\n   * Get current date/time\n   */\n  _getTime() {\n    const d = new Date();\n    return d.toISOString();\n  }\n\n\n  /**\n   * Get time difference in seconds\n   */\n  _getTimeDiff(start, end) {\n    const ds = new Date(start);\n    const de = new Date(end);\n    return (de.getTime() - ds.getTime()) / 1000;\n  }\n\n\n\n  /********** PRIVATE XHR OPTIONS *********/\n  /**\n   * Modify request headers. This is the headers sent to the server.\n   * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n   * To change it use header methods.\n   * @param {object} headers - headers object: { 'content-type': 'text/html', accept: 'application/json' }\n   * @returns {void}\n   */\n  _xhr_requestHeaders(headers) {\n    Object.keys(headers).forEach(prop => this.xhr.setRequestHeader(prop.toLowerCase(), headers[prop]));\n  }\n\n  /**\n   * Modify request timeout in miliseconds. This is the time for which will xhr wait for response from the server.\n   * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/timeout\n   * To change it use: httpClient.timeout = 120000;\n   * @param {number} ms - the timeout period\n   * @returns {void}\n   */\n  _xhr_timeout(ms) {\n    this.xhr.timeout = +ms || 0; // 0 means the request will never be timeout\n  }\n\n  /**\n   * Modify the response type. This is the reponse tye which client expects from the server. For example 'blob' if client waits for file download.\n   * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType\n   * To change it use: httpClient.responseType = 'blob';\n   * @param {string} type - text, arraybuffer, blob, document, json, ms-stream\n   * @returns {void}\n   */\n  _xhr_responseType(type) {\n    this.xhr.responseType = type || 'text';\n  }\n\n\n}\n\n\n// ESM\nexport default HTTPClientBroXHR;\n\n// window\nif (typeof window !== 'undefined') {\n  if (!window.mikosoft) { window.mikosoft = {}; }\n  window.mikosoft.HTTPClientBroXHR = HTTPClientBroXHR;\n}\n"],"names":[],"sourceRoot":""}