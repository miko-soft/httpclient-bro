{"version":3,"file":"httpclient-bro-fetch.js","mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gCAAgC,kCAAkC,KAAK;AACjJ;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,EAAE;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC,KAAK;;AAEL;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,UAAU;AACvB,eAAe;AACf;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,QAAQ,kBAAkB;AACvC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,UAAU;AACvB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA,sEAAe,kEAAkB,IAAC;;AAElC;AACA;AACA,0BAA0B;AAC1B;AACA","sources":["webpack://@mikosoft/httpclient-bro/./HTTPClientBroFetch.js"],"sourcesContent":["class HTTPClientBroFetch {\n  /**\n   * Opts {\n   *  encodeURI:boolean,\n   *  timeout:number,\n   *  responseType: ''|'text'|'blob', // 'blob' for file download (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType)\n   *  retry:number,\n   *  retryDelay:number,\n   *  maxRedirects:number,\n   *  headers:object\n   * }\n   * @param {Object} opts - HTTP Client options {encodeURI, timeout, responseType, retry, retryDelay, maxRedirects, headers}\n   */\n  constructor(opts) {\n    this.url;\n    this.protocol = 'http:';\n    this.hostname = '';\n    this.port = 80;\n    this.pathname = '/';\n    this.queryString = '';\n\n    this.opts = opts || {\n      encodeURI: false,\n      timeout: 8000,\n      responseType: '', // 'blob' for file download (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType)\n      retry: 3,\n      retryDelay: 5500,\n      maxRedirects: 3,\n      headers: {\n        authorization: '',\n        accept: '*/*' // 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'\n      }\n    };\n\n    this.timeout = this.opts.timeout;\n    this.responseType = this.opts.responseType;\n    this.req_headers = { ...this.opts.headers };\n    this.interceptor = null;\n  }\n\n  /********** REQUESTS *********/\n\n  /**\n   * Sending one HTTP request to HTTP server.\n   *  - 301 redirections are not handled.\n   *  - retries are not handled\n   * @param {string} url - https://www.example.com/something?q=15\n   * @param {string} method - GET, POST, PUT, DELETE, PATCH\n   * @param {any} bodyPayload - http body payload\n   * @returns {Promise<answer>}\n   */\n  async askOnce(url, method = 'GET', bodyPayload) {\n    const answer = {\n      requestURL: url,\n      requestMethod: method,\n      status: 0,\n      statusMessage: '',\n      https: false,\n      req: {\n        headers: this.req_headers,\n        payload: undefined\n      },\n      res: {\n        headers: undefined,\n        content: undefined\n      },\n      time: {\n        req: this._getTime(),\n        res: undefined,\n        duration: undefined\n      }\n    };\n\n    try {\n      url = this._parseUrl(url);\n      answer.requestURL = url;\n      answer.https = /^https/.test(this.protocol);\n    } catch (err) {\n      const ans = { ...answer };\n      ans.status = 400;\n      ans.statusMessage = err.message || 'Bad Request';\n      ans.time.res = this._getTime();\n      ans.time.duration = this._getTimeDiff(ans.time.req, ans.time.res);\n      return ans;\n    }\n\n    if (this.interceptor) await this.interceptor();\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    const requestOptions = {\n      method,\n      headers: this.req_headers,\n      signal: controller.signal,\n      ...(bodyPayload && !/GET/i.test(method) && {\n        body: /application\\/json/.test(this.req_headers['content-type'])\n          ? JSON.stringify(bodyPayload)\n          : bodyPayload\n      })\n    };\n\n    try {\n      const response = await fetch(url, requestOptions);\n      clearTimeout(timeoutId);\n\n      answer.status = response.status;\n      answer.statusMessage = response.statusText;\n      answer.res.headers = this._parseHeaders(response.headers);\n      answer.res.content = await response[this.responseType || 'text']();\n      answer.time.res = this._getTime();\n      answer.time.duration = this._getTimeDiff(answer.time.req, answer.time.res);\n\n      return answer;\n    } catch (error) {\n      console.log('ERRRRR:', error);\n      clearTimeout(timeoutId);\n\n      const ans = { ...answer };\n      ans.status = error.name === 'AbortError' ? 408 : 400;\n      ans.statusMessage = error.message;\n      ans.time.res = this._getTime();\n      ans.time.duration = this._getTimeDiff(ans.time.req, ans.time.res);\n\n      return ans;\n    }\n  }\n\n  /**\n   * Sending HTTP request to HTTP server.\n   *  - 301 redirections are handled.\n   *  - retries are handled\n   * @param {String} url - https://www.example.com/contact\n   * @param {String} method - GET, POST, PUT, DELETE, PATCH\n   * @param {Object} bodyPayload - http body\n   * @returns {Promise<answer>}\n   */\n  async ask(url, method = 'GET', bodyPayload) {\n    let answer = await this.askOnce(url, method, bodyPayload);\n    const answers = [answer];\n\n    let redirectCounter = 1;\n    while (!!answer && /^3\\d{2}/.test(answer.status) && redirectCounter <= this.opts.maxRedirects) {\n      const url_new = new URL(url, answer.res.headers.location);\n      answer = await this.askOnce(url_new, method, bodyPayload);\n      answers.push(answer);\n      redirectCounter++;\n    }\n\n    let retryCounter = 1;\n    while (answer.status === 408 && retryCounter <= this.opts.retry) {\n      await new Promise(resolve => setTimeout(resolve, this.opts.retryDelay));\n      answer = await this.askOnce(url, method, bodyPayload);\n      answers.push(answer);\n      retryCounter++;\n    }\n\n    return answers;\n  }\n\n  /**\n   * Fetch the JSON. Redirections and retries are not handled.\n   * @param {string} url - https://api.example.com/someurl\n   * @param {string} method - GET, POST, PUT, DELETE, PATCH\n   * @param {object|string} body - http body as Object or String JSON type\n   * @returns {Promise<answer>}\n   */\n  async askJSON(url, method = 'GET', body) {\n    let bodyPayload = body;\n    if (!!body && typeof body === 'string') {\n      try {\n        bodyPayload = JSON.parse(body);\n      } catch (err) {\n        throw new Error('Body string is not valid JSON.');\n      }\n    }\n\n    this.setReqHeaders({\n      'accept': 'application/json',\n      'content-type': 'application/json; charset=utf-8'\n    });\n\n    const answer = await this.askOnce(url, method, bodyPayload);\n    if (!!answer.res.content) {\n      try {\n        answer.res.content = JSON.parse(answer.res.content);\n      } catch (err) {\n        throw new Error('Response content is not valid JSON.');\n      }\n    }\n\n    return answer;\n  }\n\n  /**\n   * Get the HTML file content.\n   * @param {string} url - http://example.com/page.html\n   * @returns {Promise<answer>}\n   */\n  async askHTML(url) {\n    this.setReqHeaders({\n      'accept': 'text/html',\n      'content-type': 'text/html'\n    });\n    const answer = await this.askOnce(url, 'GET');\n    return answer;\n  }\n\n  /**\n   * Get the content of the Javascript file.\n   * @param {string} url - https://api.example.com/some.js\n   * @returns {Promise<answer>}\n   */\n  async askJS(url) {\n    this.setReqHeaders({\n      'accept': 'application/javascript',\n      'content-type': 'application/javascript; charset=utf-8'\n    });\n    const answer = await this.askOnce(url, 'GET');\n    return answer;\n  }\n\n  /**\n   * Send POST request where body is new FormData() object.\n   * @param {string} url - https://api.example.com/someurl\n   * @param {FormData} formData - the FormData instance\n   * @returns {Promise<answer>}\n   */\n  async sendFormData(url, formData) {\n    this.setReqHeaders({\n      'accept': '*/*'\n    });\n    this.delReqHeaders(['content-type']);\n    const answer = await this.askOnce(url, 'POST', formData);\n\n    if (!!answer.res.content) {\n      try {\n        answer.res.content = JSON.parse(answer.res.content);\n      } catch (err) {\n        console.log('WARNING: Response content is not JSON.');\n      }\n    }\n\n    return answer;\n  }\n\n  /**\n   * Convert JS Object to FormData and prepare it for sendFormData()\n   * @param {object} formObj - object which needs to be converted to FormData\n   * @returns {FormData}\n   */\n  object2formdata(formObj) {\n    const formData = new FormData();\n    for (const [key, val] of Object.entries(formObj)) { formData.set(key, val); }\n    return formData;\n  }\n\n  /**\n   * Stop the sent request immediately.\n   * @returns {void}\n   */\n  kill() {\n    // The fetch API doesn't have an equivalent of `abort` for an already completed request.\n    // This method is a no-op for now.\n  }\n\n  /**\n   * Set the interceptor function which will be executed every time before the HTTP request is sent.\n   * @param {Function} interceptor - callback function\n   * @returns {void}\n   */\n  setInterceptor(interceptor) {\n    this.interceptor = interceptor.bind(this);\n  }\n\n  /********** HEADERS **********/\n\n  /**\n   * Set HTTP request header(s).\n   * @param {object} headerObj - e.g. {Authorization:'Bearer token', Accept:'application/json'}\n   * @returns {void}\n   */\n  setReqHeaders(headerObj) {\n    for (const [key, val] of Object.entries(headerObj)) {\n      this.req_headers[key.toLowerCase()] = val;\n    }\n  }\n\n  /**\n   * Delete header by key.\n   * @param {string[]} headerArr - the array of keys\n   * @returns {void}\n   */\n  delReqHeaders(headerArr) {\n    for (const key of headerArr) {\n      delete this.req_headers[key.toLowerCase()];\n    }\n  }\n\n  /********** UTILS **********/\n\n  /**\n   * Parse the URL and update the class instance properties.\n   * @param {string} url - the URL to parse\n   * @returns {string} - formatted URL\n   */\n  _parseUrl(url) {\n    const parsedURL = new URL(url);\n\n    this.protocol = parsedURL.protocol;\n    this.hostname = parsedURL.hostname;\n    this.port = parsedURL.port || (parsedURL.protocol === 'https:' ? 443 : 80);\n    this.pathname = parsedURL.pathname;\n    this.queryString = parsedURL.search;\n\n    if (!!this.opts.encodeURI) {\n      url = encodeURI(url);\n    }\n\n    return url;\n  }\n\n  /**\n   * Get the current time in milliseconds.\n   * @returns {number}\n   */\n  _getTime() {\n    return Date.now();\n  }\n\n  /**\n   * Get the duration between two time points in milliseconds.\n   * @param {number} t1 - start time\n   * @param {number} t2 - end time\n   * @returns {number}\n   */\n  _getTimeDiff(t1, t2) {\n    return t2 - t1;\n  }\n\n  /**\n   * Parse the headers from the Fetch response.\n   * @param {Headers} headers - the Headers object from Fetch response\n   * @returns {object} - headers as a plain object\n   */\n  _parseHeaders(headers) {\n    const headersObj = {};\n    headers.forEach((value, key) => {\n      headersObj[key] = value;\n    });\n    return headersObj;\n  }\n}\n\n\n// ESM\nexport default HTTPClientBroFetch;\n\n// window\nif (typeof window !== 'undefined') {\n  if (!window.mikosoft) { window.mikosoft = {}; }\n  window.mikosoft.HTTPClientBroFetch = HTTPClientBroFetch;\n}\n"],"names":[],"sourceRoot":""}